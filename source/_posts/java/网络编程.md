---
title: 网络编程、TCP协议、TCP传输数据、多线程连接池通讯、网络结构、编写web服务器
tags:
  - Java基础
  - 网络编程
  - TCP
  - 网络通讯
categories: Java学习笔记
declare: true
cover: >-
  https://image.baidu.com/search/down?tn=download&word=download&ie=utf8&fr=detail&url=https%3A%2F%2Ftimgsa.baidu.com%2Ftimg%3Fimage%26quality%3D80%26size%3Db9999_10000%26sec%3D1585235179980%26di%3Df71aff38a58819aea030ad5d01b2e0d1%26imgtype%3D0%26src%3Dhttp%253A%252F%252Fwww.bm0315.com%252Fuploads%252Fallimg%252F191224%252F040J32D9_0.jpg&thumburl=https%3A%2F%2Fss0.bdstatic.com%2F70cFvHSh_Q1YnxGkpoWK1HF6hhy%2Fit%2Fu%3D1444070507%2C3220770755%26fm%3D26%26gp%3D0.jpg
abbrlink: 2202648686
data: 2020-03-27 00:00:00
---

# 软件结构

## c/s结构

- 全称Client/Server结构，是指客户端和服务器结构。
- 是建立在局域网的基础上的。一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供连接和数据交换服务. 
- 更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑. 

## B/S结构

- 全称为Browser/server，指的是浏览器和服务器结构
- 建立在广域网的基础上的.
-  对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上.

# 网络通信协议和TCP/IP协议

1. 网络通信协议：通过计算机网路可以使更多的计算机时间连接，位于同一网络中的计算机在进行连接和通信时，需要遵守一定的规则。这些连接和通信的规则就称为网通信协议
2. tcp/ip协议：传输控制协议/因特网互联协议（Transmission Control Protocol/ Internet Protocol） 是Internet最基本、广泛的协议，定义了计算机如何连入互联网，以及数据传输的标准，它内部包含了一系列来处理数据通信的协议，并采用了多层的分层模型。每一层都呼叫它的下一层来完成自己的需求

- OSI七层模型
- Tcp/ip四层模型
- TCp/ip五层模型

![G96iJ1.png](https://s1.ax1x.com/2020/03/27/G96iJ1.png)

**网络接口层：**网络接口是用于定义物理传输通道，如网线

**网络层：**是整个tcp/ip协议核心，只要将传输的数据进行分组，将分组数据发送到目标计算机或网络

**传输层：**主要使网络程序进行通信，在通信的时候，可以采用tcp协议，也可以使用udp协议（我们主要是在这一层做操作）

**应用层：**负责应用程序的协议，例如http，ftp协议等

## 分类协议

java.net包中包含了类和接口，提供低层次的通信细节，使用该这些类和接口专注网络程序开发，不用考虑通信细节，该包提供了常用的两种网络协议，tcp和udp协议

- udp：：ternet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。无连接的是 UDP，它除了给应用程序发送数据包功能并允许它们在所需的层次上架构自己的协议之外，几乎没有做什么特别的事情。适合于一次传输少量数据64k以内
- tcp：（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。

### tcp的三次握手

在发送数据的准备阶段，客户端与服务器有三次交互

1. 第一次：客户端向服务器发出连接请求，等待服务器确认
2. 第二次：服务器向客户端回送一个响应，通知科客户端收到了连接请求
3. 第三次：客户端再次向服务器发送确认信息，确认连接

> 所有的请求都是由客户端发出，服务端不能主动向客户端发送请求

# 网络编程的三要素

## 协议

采用的通信协议，即上文介绍的协议

## ip地址

定位网络中计算机的位置

> ipv4：https://baike.baidu.com/item/IPv4/422599?fr=aladdin
>
> ipv6:https://baike.baidu.com/item/IPv6/172297?fr=aladdin

## 端口号

定位计算机中的应用程序

# TCP通信程序

tcp通信能实现两台计算机之间的数据交互，通信的两端，分为客户端和服务器端

两端通信的时候的步骤：

1. 服务端程序需要先启动，等待客户端里连接
2. 客户端主动连接服务器，连接成功了才能通信，服务端不能主动连接客户端

java中提供了两个类实现tcp通信：

1. 客户端：java.net.Socket 类中，创建Socket对象，向服务器发出 连接请求，服务端相应请求，两者建立连接开始通信
2. 服务端：java.net.ServerSocket 类，创建ServerSocket对象，类似开启了一个服务，等待Socket客户端连接

## Socket类

实现客户端套接字，套接字指的是两台设备之间通讯的端点

### Socket构造方法

- public Socket(String host,int port):创建套接字对象将其连接到指定主机上的指定端口号，**如果指定的host是null，则相当于指定地址回送地址**

```java
   //1创建一个客户端连接对象
        Socket socket = new Socket("localhost",8080);
//localhost:本地服务器也可以写成127.0.0.1
//8080：指定服务器端口号
```

## ServerSocket类

实现服务器端套接字

### ServerSocket构造方法

-  public ServerSocket(int port) ：创建一个指定端口号为8080的服务器套接字对象

```java
//1.创建服务器套接对象
ServerSocket serverSocket = new ServerSocket(8080);
```



> 这里需要注意，需要先启动服务器在来启动客户端，否则客户端回报错找不到该端口号的服务器

### ServerSocket成员方法

```Java
public Socket accept() //侦听并接受连接，返回一个新的socket对象，用于和客户端实现通信，该方法会一直阻塞，知道建立连接
```

```java
//1.创建服务器套接对象
ServerSocket serverSocket = new ServerSocket(8080);
Socket socket = serverSocket.accept();//侦听并接受连接，返回一个新的socket对象，用于和客户端实现通信，该方法会一直阻塞，知道建立连接
System.out.println("建立客户端连接" + socket);
```

## 网络传输图解（使用字节流传输数据）

### 客户端向服务器发送数据

![](https://pic.downk.cc/item/5e81b722504f4bcb0424f7a6.png)

### 服务器向客户端发送数据

![](https://pic.downk.cc/item/5e82aba2504f4bcb04cb59ee.png)

## 客户端向服务器通信代码演示

### 客户端代码

```java
package com.yq;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
public class TcpCilent {
    public static void main(String[] args) throws IOException {
        //1创建一个客户端连接对象
        Socket socket = new Socket("localhost",8080);
       //2获取字节输出流对象
        OutputStream out= socket.getOutputStream();
        //3向服务器发送数据
        out.write("大脚好".getBytes());
        //从网络中读取数据
        InputStream in = socket.getInputStream();
        byte [] bytes= new byte[1024];
        int len = in.read(bytes);
        System.out.println("获取服务器给的数据："+new String(bytes,0,len));

        //4关闭字节输出流
        out.close();
        in.close();
        //5关闭连接通道
        socket.close();
    }
}
//本地iploacalhost 127.0.0.1
```

### 服务器端代码

```java
package com.yq;
import jdk.internal.util.xml.impl.Input;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;
public class TcpServer {
    public static void main(String[] args) throws IOException {
        //1.创建服务器套接对象
        ServerSocket serverSocket = new ServerSocket(8080);
        System.out.println("启动服务器，等待客户端的连接");

        while (true){
            //接受客户端的信息
            Socket socket = serverSocket.accept();//侦听并接受连接，返回一个新的socket对象，用于和客户端实现通信，该方法会一直阻塞，知道建立连接
            System.out.println("建立客户端连接" + socket);

            //3.获取 客户端发送过来的数据
            InputStream in = socket.getInputStream();
            byte[] bytes = new byte[1024];
            /**
             *
             int len = 0;
             while ((len = in.read(bytes)) != -1) {
             System.out.println(new String(bytes, 0, len));
             }
             */
            int len = in.read(bytes);
            String name = new String (bytes,0,len);
            System.out.println(name);
            //4给客户端发送信息 将内存中的数据写到网络里

            //4关闭input流
            in.close();
            //5关闭等待的客户端
            socket.close();
        }

    }
}
```

### 运行图示

![](https://pic.downk.cc/item/5e82a96f504f4bcb04c9e2db.png)

![](https://pic.downk.cc/item/5e82a9a8504f4bcb04ca121c.png)

## 服务器向客户端通信代码演示（服务器连接多个客户端）

### 客户端代码

```java
package com.yq;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;

public class TcpCilent {
    public static void main(String[] args) throws IOException {
        //1创建一个客户端连接对象
        Socket socket = new Socket("localhost",8080);
       //2获取字节输出流对象
        OutputStream out= socket.getOutputStream();
        //3向服务器发送数据
        out.write("你好啊服务器，我是客户端".getBytes());
        //从网络中读取数据
        InputStream in = socket.getInputStream();
        byte [] bytes= new byte[1024];
        int len = in.read(bytes);
        System.out.println("获取服务器给的数据："+new String(bytes,0,len));

        //4关闭字节输出流
        out.close();
        in.close();
        //5关闭连接通道
        socket.close();

    }
}

//本地iploacalhost 127.0.0.1

```

### 服务器端代码

```java
package com.yq;

import jdk.internal.util.xml.impl.Input;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class TcpServer {
    public static void main(String[] args) throws IOException {
        //1.创建服务器套接对象
        ServerSocket serverSocket = new ServerSocket(8080);
        System.out.println("启动服务器，等待客户端的连接");

        while (true){
            //接受客户端的信息
            Socket socket = serverSocket.accept();//侦听并接受连接，返回一个新的socket对象，用于和客户端实现通信，该方法会一直阻塞，知道建立连接
            System.out.println("建立客户端连接" + socket);

            //3.获取 客户端发送过来的数据
            InputStream in = socket.getInputStream();
            byte[] bytes = new byte[1024];
            /**
             *
             int len = 0;
             while ((len = in.read(bytes)) != -1) {
             System.out.println(new String(bytes, 0, len));
             }
             */
            int len = in.read(bytes);
            String name = new String (bytes,0,len);
            System.out.println(name);
            //4给客户端发送信息 将内存中的数据写到网络里

            //获取字节输出流
            OutputStream out= socket.getOutputStream();
            out.write(("你好"+name).getBytes());

            out.close();
            //4关闭input流
            in.close();
            //5关闭等待的客户端
            socket.close();
        }

    }
}

```

### 运行图示

![](https://pic.downk.cc/item/5e82aafc504f4bcb04caecdc.png)

![](https://pic.downk.cc/item/5e82ab08504f4bcb04caf4da.png)

# 使用多线程，线程连接池通信（使用字符流传输数据）

客户端代码

```java
package com.zmc;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.net.Socket;
import java.util.Scanner;

public class TcpCilent {
    public static void main(String[] args) throws IOException {
        //1创建一个客户端连接对象
        Socket socket = new Socket("localhost",8080);
       //2获取字符输出流对象 客户端向服务器发送数据
        PrintStream out = new PrintStream(socket.getOutputStream());
        //从键盘输入内容发送个服务器
        Scanner sc = new Scanner(System.in);
        while (sc.hasNextLine()){
            String content = sc.nextLine();
            out.println(content);
            if ("Q".equals(content)){
                break;
            }

        }
        out.close();
        socket.close();


        //5关闭连接通道
//        socket.close();

    }
}
```

服务器端代码

```java
package com.zmc;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class TcpServer {
    public static void main(String[] args) throws IOException {
        //1.创建服务器套接对象
        ServerSocket serverSocket = new ServerSocket(8080);
        System.out.println("启动服务器，等待客户端的连接");
        while (true){
            Thread t = new Thread(new Runnable() {
                @Override
                public void run() {
                    try
                    {
                        //2.接受客户端的信息
                        Socket socket = serverSocket.accept();//侦听并接受连接，返回一个新的socket对象，用于和客户端实现通信，该方法会一直阻塞，知道建立连接
                        //3.读取客户端发送过来的数据
                        BufferedReader br= new BufferedReader(new InputStreamReader(socket.getInputStream()));
                        System.out.println(br.readLine());

                        String lint = "";
                        while ((lint=br.readLine())!=null){
                            System.out.println(lint);

                            //5关闭等待的客户端 和流
//                    br.close();

//                    socket.close();
                        }
                        System.out.println("客户端"+ socket+"退出");
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            });
            t.start();


        }


    }
}
```

## 使用多线程实现文件上传

![](https://pic.downk.cc/item/5e82b26c504f4bcb04d0b102.png)

### 单个文件上传（单线程）

#### 客户端

```java
package com.file;

import com.sun.xml.internal.bind.v2.runtime.unmarshaller.SAXConnector;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;


public class FileUploadClient {
    public static void main(String[] args) throws IOException {
        //1.创建一个客户端的连接对象
       Socket socket = new Socket("127.0.0.1", 8080);
       //2.创建字节输入流
        InputStream inputStream = new FileInputStream("F:\\file\\ccc.md");
        //3.获取客户点socket字节输出流
        OutputStream outputStream = socket.getOutputStream();
        //4.读取ccc.mdd的内容到内存
        byte [] bytes = new  byte[1024];
        int len = 0;
        while ((len = inputStream.read(bytes))!=-1){
         //5.读取到的内容写到socket通道中
            outputStream.write(bytes,0,len);
        }
        //6.释放资源
        outputStream.close();
        inputStream.close();
        socket.close();
    }
}
```

#### 服务器端

```java
package com.file;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class FileUploadServer {
    public static void main(String[] args) throws IOException {
        //1.创建服务器的socket对象
        ServerSocket serverSocket = new ServerSocket(8080);
        // 2.获取客户端socket
        Socket socket = serverSocket.accept();
        //3.获取客户端socket的字节输入流
        InputStream in = socket.getInputStream();
        //4.创建一个字节输出流
        String filename = System.currentTimeMillis()+".md";
        OutputStream outputStream = new FileOutputStream("file/");
        //5.读取客户端socket的内容到服务器的内存
        byte [] bytes = new byte[1024];
        int len = 0;
        while ((len = in.read(bytes))!=-1){
            //6.将内存中读取的字节流写入文件
            outputStream.write(bytes,0,len);
        }
        //7.释放资源
        outputStream.close();
        in.close();
        socket.close();
        System.out.println("文件上传成功"+filename);
    }
}

```

#### 结果图示

![](https://pic.downk.cc/item/5e82bba5504f4bcb04d86382.png)

### 多个文件上传（单线程）

> 需要在改项目目录下新建file目录，这里使用绝对路径来作为上传目录

#### 客户端

```java
package com.file;

import com.sun.xml.internal.bind.v2.runtime.unmarshaller.SAXConnector;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;


public class FileUploadClient {
    public static void main(String[] args) throws IOException {

        //上传10次
       for (int i = 0;i<10;i++){
        //1.创建一个客户端的连接对象
       Socket socket = new Socket("127.0.0.1", 8080);
       //2.创建字节输入流
        InputStream inputStream = new FileInputStream("F:\\file\\ccc.md");
        //3.获取客户点socket字节输出流
        OutputStream outputStream = socket.getOutputStream();
        //4.读取ccc.mdd的内容到内存
        byte [] bytes = new  byte[1024];
        int len = 0;
        while ((len = inputStream.read(bytes))!=-1){
         //5.读取到的内容写到socket通道中
            outputStream.write(bytes,0,len);
        }
        //6.释放资源
        outputStream.close();
        inputStream.close();
        socket.close();
        }
    }
}
```

#### 服务器端

```java
package com.file;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class FileUploadServer {
    public static void main(String[] args) throws IOException {
        //1.创建服务器的socket对象
        ServerSocket serverSocket = new ServerSocket(8080);

        while (true){
        // 2.获取客户端socket
        Socket socket = serverSocket.accept();
            System.out.println("文件上传开始");
        //3.获取客户端socket的字节输入流
        InputStream in = socket.getInputStream();
        //4.创建一个字节输出流
        String filename = System.currentTimeMillis()+".md";
        OutputStream outputStream = new FileOutputStream("file/"+filename);
        //5.读取客户端socket的内容到服务器的内存
        byte [] bytes = new byte[1024];
        int len = 0;
        while ((len = in.read(bytes))!=-1){
            //6.将内存中读取的字节流写入文件
            outputStream.write(bytes,0,len);
        }
        //7.释放资源
        outputStream.close();
        in.close();
        socket.close();
        System.out.println("文件上传成功"+filename);
        }
    }
}
```

#### 运行图示

![](https://pic.downk.cc/item/5e82be65504f4bcb04dae7ab.png)

![](https://pic.downk.cc/item/5e82be5a504f4bcb04daddcf.png)

### 使用线程池来实现多个客户端上传文件（多线程）

#### 服务器端

```Java
package com.file;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class FileUploadServer {
    public static void main(String[] args) throws IOException {
        //1.创建服务器的socket对象
        ServerSocket serverSocket = new ServerSocket(8080);
        //创建线程池
       ExecutorService pool = Executors.newFixedThreadPool(10);
        while (true){
        // 2.获取客户端socket
        Socket socket = serverSocket.accept();

        //开启多线程
            pool.submit(new Runnable() {
                @Override
                public void run() {
                    System.out.println("文件上传开始");
                    //3.获取客户端socket的字节输入流
                    InputStream in = null;
                    try {
                        in = socket.getInputStream();
                        //4.创建一个字节输出流
                        String filename = System.currentTimeMillis()+".md";
                        OutputStream outputStream = new FileOutputStream("file/"+filename);
                        //5.读取客户端socket的内容到服务器的内存
                        byte [] bytes = new byte[1024];
                        int len = 0;
                        while ((len = in.read(bytes))!=-1){
                            //6.将内存中读取的字节流写入文件
                            outputStream.write(bytes,0,len);
                        }
                        //7.释放资源
                        outputStream.close();
                        in.close();
                        socket.close();
                        System.out.println("文件上传成功"+filename);
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            });

             }
    }
}
```

#### 运行图示

![](https://pic.downk.cc/item/5e82c03c504f4bcb04dc99be.png)

# 编写web服务器

> 这里用到了网络编程、多线程、tcp、io的相关知识
>
> 这里用到了网页，所以是b/s架构
>
> 需要先在项目目录里引入html网页，才能更好的展示运行效果

![](https://pic.downk.cc/item/5e82fa9a504f4bcb04086135.png)

## 创建服务器端口为8080（字节流）

### 创建HttpServer服务端类

```java
package com.webServer;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;

public class HttpServer {
    public static void main(String[] args) throws IOException {
        //1.创建服务器的Socket
        ServerSocket serverSocket = new ServerSocket(8080);
        //2.接受浏览器发送过来的请求
        Socket socket = serverSocket.accept();
        if (socket!=null){
            System.out.println("浏览器请求成功");
        }
        //3.关闭客户端的socket
        serverSocket.close();
    }
}
```

### 运行图示

![](https://pic.downk.cc/item/5e82c556504f4bcb04e0838f.png)

![](https://pic.downk.cc/item/5e82c54e504f4bcb04e07cf3.png)

## 使用【字符流传输】创web建服务器

### 服务器端代码

```java
package com.webServer;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class HttpServer {
    public static void main(String[] args) throws IOException {
        //1.创建服务器的Socket
        ServerSocket serverSocket = new ServerSocket(8080);
        //2.接受浏览器发送过来的请求
        while (true){
            Socket socket = serverSocket.accept();
            //将浏览器发送过来的字节输入流，转换成字符缓冲输入流
            InputStreamReader isr = new InputStreamReader(socket.getInputStream());
            BufferedReader br = new BufferedReader(isr);
            String fileName = br.readLine().split(" ")[1];
            System.out.println(fileName);

            //3.响应浏览器的请求，向浏览器发送数据
            //创建一个打印输入流
            PrintStream out = new PrintStream(socket.getOutputStream());
            out.println("HTTP/1.1 200 OK");//状态行
            out.println("Content-Type:text/html;charset=utf-8");
            out.println();//空行

            //4.响应正文
            // 将请求的页面内容写在网络里
            // 先将浏览器请求的内容从服务器硬盘读取到服务器的内存
            InputStream in = new FileInputStream("html"+fileName);
            BufferedInputStream bfin = new BufferedInputStream(in);
            byte [] bytes = new byte[1024];
            int len = 0;
            while ((len = in.read(bytes))!=-1)
            {
                out.write(bytes,0,len);//响应正文

            }

                //释放资源
            in.close();
            br.close();
            out.close();
            socket.close();
        }
    }
}
```

### 运行图示

![](https://pic.downk.cc/item/5e82e472504f4bcb04f734a1.png)

## 服务器中使用多线程

```java
package com.webServer;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class HttpServer {
    public static void main(String[] args) throws IOException {
        //1.创建服务器的Socket
        ServerSocket serverSocket = new ServerSocket(8080);
        //2.接受浏览器发送过来的请求
        while (true){
            Socket socket = serverSocket.accept();

            ExecutorService tool = Executors.newFixedThreadPool(10);
            tool.submit(new Runnable() {
                @Override
                public void run() {

                    //将浏览器发送过来的字节输入流，转换成字符缓冲输入流
                    InputStreamReader isr = null;
                    try {
                        isr = new InputStreamReader(socket.getInputStream());
                        BufferedReader br = new BufferedReader(isr);
                        String fileName = br.readLine().split(" ")[1];
                        System.out.println(fileName);
                        //3.响应浏览器的请求，向浏览器发送数据
                        //创建一个打印输入流
                        PrintStream out = new PrintStream(socket.getOutputStream());

                        //判断请求的文件是否存在
                        File file = new File("html"+fileName);
                        if (file.exists()){
                            out.println("HTTP/1.1 200 OK");//状态行
                            out.println();//空行
                        }else {
                            out.println("HTTP/1.1 404 OK");//状态行
                            out.println("Content-Type:text/html;charset=utf-8");
                            out.println();//空行

                            br.close();
                            out.close();
                            socket.close();
                            return;
                        }


                        //4.响应正文
                        // 将请求的页面内容写在网络里
                        // 先将浏览器请求的内容从服务器硬盘读取到服务器的内存
                        InputStream in = new FileInputStream("html"+fileName);
                        BufferedInputStream bfin = new BufferedInputStream(in);
                        byte [] bytes = new byte[1024];
                        int len = 0;
                        while ((len = in.read(bytes))!=-1)
                        {
                            out.write(bytes,0,len);//响应正文

                        }

                        //释放资源
                        in.close();
                        br.close();
                        out.close();
                        socket.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }


                }
            });

        }
    }
}
```

![](https://pic.downk.cc/item/5e82e7a6504f4bcb04f994f3.png)