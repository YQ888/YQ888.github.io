---
title: 多线程
tags:
  - Java基础
  - 多线程
categories: Java学习笔记
declare: true
cover: >-
  https://image.baidu.com/search/down?tn=download&word=download&ie=utf8&fr=detail&url=https%3A%2F%2Ftimgsa.baidu.com%2Ftimg%3Fimage%26quality%3D80%26size%3Db9999_10000%26sec%3D1585235179980%26di%3Df71aff38a58819aea030ad5d01b2e0d1%26imgtype%3D0%26src%3Dhttp%253A%252F%252Fwww.bm0315.com%252Fuploads%252Fallimg%252F191224%252F040J32D9_0.jpg&thumburl=https%3A%2F%2Fss0.bdstatic.com%2F70cFvHSh_Q1YnxGkpoWK1HF6hhy%2Fit%2Fu%3D1444070507%2C3220770755%26fm%3D26%26gp%3D0.jpg
abbrlink: 1462361889
data: 2020-03-28 00:00:00
---



# 多线程的相关概念

## 并发和并行

**并发 ：**同一时刻只能处理一个任务（java中的多线程采用的方式）

​	单核cpu电脑，在同一时刻只能运行一个程序运行多个程序看似是并行实则并发

**并行：**同一时刻可以处理多个任务（同时进行）

## 线程与进程

**进程：**是指在内存中的运用程序，每个进程都一个独立的进程空间，一个应用程序可以同时运行多个进程；

![GSSXee.png](https://s1.ax1x.com/2020/03/26/GSSXee.png)

**线程：**线程是进程中的一个执行单元，一个进程中至少有一个线程，一个程序运行后至少有一个进程，一个进程可以包含多个线程。

![GSpnWq.png](https://s1.ax1x.com/2020/03/26/GSpnWq.png)

## cpu（中央处理器）调度

**这里的调度是对线程进行操作，非进程**

分时调度：cpu平均分配每个线程的占用时间

抢占式调度：优先让级别高的线程使用cpu，如果级别相同，则随机选择一个（线程随机），**java采用的调度方式**

## 主线程

java虚拟机启动后，有一个线程从main方法开始执行，然后到main方法结束的时候结束这个就是java中的主线程

实现一个主线程负责执行一个循环，在用另外一个线程负责其他代码来执行，最终实现部分代码同时执行

通过java多线程技术来解决

>  main启动后，最少运行了几个线程：	1.主线程 	2.垃圾回收线程

# java的多线程

创建线程的两种方法：

- ​	继承 Thread类
- ​	实现Runnable接口

## Thread类

**构造方法:**

- public Thread()	分配一个新的线程对象
- public Thread(String name)  分配一个指定名字的新的线程对象
- public Thread(Runnable target)   分配一个带有指定目标的新的线程对象
- public Thread(Runnable target , String name) 分配一个带有指定目标新的线程对象并指定名字

**常用方法：**

- public String getName() 获取当前线程名字：**通过创建对象的先后顺序给该线程对象命名**默认冲Thread-0开始‘

  如果需要修改默认名，在调用多线程对象的时候使用指定名字的构造方法来实例对象

  这需要注意，**父类的构造方法是不能被子类继承的** ，所以我们在使用父类带参的构造方法的时候，子类需要重写带参的构造方法再通过super来调用父类的带参的构造方法

  ```java
   
      public MyThread02() {
      }
  
      public MyThread02(String name) {
          super(name);
      }
  
  //创建线程对象的时候，给线程起名字
          MyThread02 thread022 = new MyThread02("线程-100");
  ```

- publice void start() 导致此线程开始执行，java虚拟机调用此线程的run方法

- public void run() 此线程要执行的任务在此方法里定义的代码

- public startic void sleep(long millis) 使当前线正在执行的线程以指定的毫秒数暂停

- public startic Thread currentThread() 返回当前正在执行线程对象的引用

**创建线程的步骤：**

1. 定义一个类继承Thread
2. 重写run() 方法，run方法相当于其他线程的main方法
3. 创建子类对象，就是创建线程对象
4. 调用子类对象的start()  方法，开启线程并让线程执行，同时告诉jvm调用run方法

创建Thread多线程实例代码：

```java
class MyThread01 extends Thread {
    @Override
    public void run() {
       // 可以理解成子线程的main方法
        for (int i = 0;i<10;i++){
            System.out.println("子线程");
        }
    }

    public static void main(String[] args) {
        //创建一个多线程的对象
        MyThread01  thread = new MyThread01();
        // 启动一个子线程
        thread.start();
        for (int i = 0;i<10;i++){
            System.out.println(i+"主线程");
        }

    }
}

```

**结构图示：**

![GS1M5R.png](https://s1.ax1x.com/2020/03/26/GS1M5R.png)

实现多线程Thread中的常用方法实例代码：

```java
public class MyThread02 extends Thread {
    public MyThread02() {
    }

    public MyThread02(String name) {
        super(name);
    }

    @Override
    public void run() {
      try {
          for (int i = 0 ;i<10;i++){
              Thread.sleep(1000);
              System.out.println(Thread.currentThread().getName());
          }
      }catch (InterruptedException e){
          e.printStackTrace();
      }
    }

    public static void main(String[] args) throws InterruptedException {

        /**
         *
        MyThread02 thread02 = new MyThread02("线程-1");

        //创建线程对象的时候，给线程起名字
        MyThread02 thread022 = new MyThread02("线程-100");
//        getName 获取线程名字
        System.out.println(thread02.getName());

        //thread02.start();//开启了一个子线程
        thread02.run();//调用了对象的普通方法，并没有开启线程
        System.out.println("主线程");
         */

        Thread thread = new MyThread02("子线程-0");
        Thread thread1 = new MyThread02("子线程-1");
        thread.start();
        thread1.start();
        for (int i = 0 ;i<10;i++){
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName());
        }
    }
}

```

**调用start()以后，run()不会立即执行，因为子线程会和主线程争夺cpu资源，在这里是有一段时间的**



## 实现Runnable接口

实例代码：

```java
public class MyRunnable01 implements Runnable {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        //1 创建线程类的对象
        MyRunnable01 myThread03 = new  MyRunnable01();
        Thread thread = new Thread(myThread03,"线程0001");
        thread.start();

    }
}

```

使用匿名类的方式

```java
public class MyThread03 {
    public static void main(String[] args) {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {

                System.out.println(Thread.currentThread().getName());
            }
        });
        //启动线程
        thread.start();
    }
}

```

**start()不能调用多次**

## 调用run方法和start方法的区别

1. 线程对象调用run方法不能开启方法，而是普通对象调用方法
2. 线程对象调用start方法，开启线程，并让jvm调用run方法在开启的线程中执行

1. 适合多个相同的程序代码和线程处理同一个资源
2. 可以避免java中的继承限制（不能访问父类的私有成员）
3. 增阿程序的健壮性，代码可以被多个线程共享
4. 线程池只能放入Runnable或Callable类线程，不能放入Thread的子类

# 线程池



## 线程池的概念

线程池，就是一个容纳多个线程的**容器**，里面的**线程可以反复使用**，省去了频繁创建线程对象的操作，无需反复创建线程过多的耗费资源

![GSyVb9.png](https://s1.ax1x.com/2020/03/26/GSyVb9.png)

使用线程池的好处：

- 降低资源消耗，减少创建和销毁线程的次数，每个工作线程都可以被重复使用，可执行多个任务；
- 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行
- 提高线程的可管理型性，可以根据系统的承受能力，调整线程池中工作线程的数目，防止因为消耗过多的内存，让服务器死机



## 线程池的使用

java中线程池的顶级接口是java.util.concurrent.Executor严格上说，该接口并不是

一个线程池，而是一个执行线程的工具，真正的线程池接口是java .util.concurrent.ExecutorService建议使用Executors工具类来创建线程池对象（java中有s的都是工具类）

Executors类中创建线程池的方法如下

- public strice ExecutorService newFixedThreadPool(int nThreads):返回线程池对象（创建的是有界线程，也就说是能指定线程池中的线程个数）

获取了ExecutorService 对象后 定义如下方法使用线程池对象

- public Future<?> submit(Runnable task)：获取线程池中指定某个线程对象，并执行；Future接口是用来记录线程执行完毕后的结果，

**使用线程池的步骤：**

1. 创建线程池对象
2. 创建Runnable接口子类对象，（task）
3. 提交Runnable接口子类对象，（take task）
4. 关闭线程池（一般不做）

实例代码:

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolDemo {
    public static void main(String[] args) {
        //1.创建一个线程池对象 线程池有两个线程对象

        //建议使用该工具类获取线程池的对象不要直接new	ExecutorService

        ExecutorService pool = Executors.newFixedThreadPool(2);



        MyRunnable01 t1 = new MyRunnable01();//实例Runnable对象
        MyRunnable01 t2 = new MyRunnable01();
        MyRunnable01 t3 = new MyRunnable01();

        pool.submit(t1);//提交对象
        pool.submit(t2);
        pool.submit(t3);
        pool.shutdown();//关闭线程池
    }
}

```

# 线程安全

如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。**多线程程序每次运行结果和单线程运行结果一样，其他的变量的值也和预期一样，这就是线程安全**

案例：电影院卖票 10张票，3个售卖窗口

代码：

```
public class Ticket01 implements Runnable{
    private  int ticket = 10;//电影票的数量
    @Override
    public void run() {
        while (true){

     
                if (ticket>0){
                    String name = Thread.currentThread().getName();//获取运行线程的名称
                    System.out.println(name+"->"+(ticket--));
                }
 
        }

    }

    public static void main(String[] args) {
        Ticket01 ticket = new Ticket01();
        Thread thread = new Thread(ticket,"窗口1");
        Thread thread2 = new Thread(ticket,"窗口2");
        Thread thread3 = new Thread(ticket,"窗口3");
        thread.start();//窗口一开始售票
        thread2.start();//窗口2开始售票
        thread3.start();//窗口2开始售票
    }
}

```

结果如图：

![GSzvSx.png](https://s1.ax1x.com/2020/03/26/GSzvSx.png)

这里就出现了线程不安全

> 线程安全问题都是由全局变量及静态变量引起的，如果每个线程中对全局变量，静态变量只有读的操作，没有写的操作，一般来说，这个全局变量是线程安全的。如果有多个线程同时执行写的操作，一般都是需要考虑线程同步的，否则的话就可能影响线程安全。

# 线程同步

当我们使用多个线程访问同一资源，且多个线程对资源有写的操作，就容易出现线程安全问题，解决上述多线程并发访问一个资源的安全性问题，java提供了**线程同步机制synchronized**来解决

三种方式完成同步操作：

- 同步代码块
- 同步方法
- 同步锁

## 同步代码块

synchronize 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问语法：

```java
           synchronized (同步锁对象) {
           	需要同步操作的代码
           }
```

同步锁：

对象同步锁只是一个概念，可以想象在对象上标记了一个锁



1. 锁对象可以是任意类型
2. 多个线程对象，要使用一个锁对象

> 在任何时候，最多允许一个线程拥有同步锁，谁拿到锁就进入代码块，其他只能在外面等着

实例代码：

```java
import static java.lang.Thread.sleep;

public class Ticket01 implements Runnable{
    private  int ticket = 10;//电影票的数量
    @Override
    public void run() {
        while (true){

           synchronized (this) {
               if (ticket > 0) {

                   String name = Thread.currentThread().getName();//获取运行线程的名称
                   System.out.println(name + "->" + (ticket--));
                   try {
                       sleep(1000);
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   }
               }
           }

        }

    }

    public static void main(String[] args) {
        Ticket01 ticket = new Ticket01();
        Thread thread = new Thread(ticket,"窗口1");
        Thread thread2 = new Thread(ticket,"窗口2");
        Thread thread3 = new Thread(ticket,"窗口3");
        thread.start();//窗口一开始售票
        thread2.start();//窗口2开始售票
        thread3.start();//窗口2开始售票
    }
}

```

## 同步方法

使用synchronize 修饰的方法，就叫同步方法，保证一个线程执行该方法的时候，其他线程只能在外等待

```java
public synchronized void method ()
{
	可能会产生线程安全问题的代码
}
```

代码实例

```java
public class Ticket02 implements Runnable{
    private  int ticket = 10;//电影票的数量
    @Override
    public void run() {
        while (true){
                sellTicket();
        }

    }
    public synchronized void  sellTicket () {

        if (ticket>0){
            String name = Thread.currentThread().getName();//获取运行线程的名称
            System.out.println(name+"->"+(ticket--));
        }
    }

    public static void main(String[] args) {


        StringBuilder sb = new StringBuilder();
        StringBuffer stringBuffer = new StringBuffer();

        stringBuffer.append("hello");

        Ticket02 ticket = new Ticket02();
        Thread thread = new Thread(ticket,"窗口1");
        Thread thread2 = new Thread(ticket,"窗口2");
        Thread thread3 = new Thread(ticket,"窗口3");
        thread.start();//窗口一开始售票
        thread2.start();//窗口2开始售票
        thread3.start();//窗口2开始售票

        /**
         * StringBuffer 线程安全
         * StringBilder 线程不安全 效率高
         *
         * HashMap  线程不安全
         * HasTable  线程安全
         *
         * ArrayList 线程不安全
         * Victor  线程安全
         *
         *
         */


    }
}

```

## 同步锁

java.util.concurrent.locks.Lock 机制提供了比synchronize代码块和synchronize方法更广泛的锁定操作

Lock锁也成同步锁，加锁和释放锁方法化了，

- public void lock():加锁
- public void unlock：释放锁，解锁

**注意：创建锁的对象的时候必须在run方法外，这样才能保证左右线程都是用的同一把锁**

代码实例：

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Ticket03 implements Runnable{
    private  int ticket = 10;//电影票的数量
    private Lock lock = new ReentrantLock();//创建锁
    @Override
    public void run() {
        while (true){

            lock.lock();//加锁
                if (ticket>0){
                    String name = Thread.currentThread().getName();//获取运行线程的名称
                    System.out.println(name+"->"+(ticket--));
                }
            lock.unlock();//释放锁

        }

    }

    public static void main(String[] args) {


        StringBuilder sb = new StringBuilder();
        StringBuffer stringBuffer = new StringBuffer();

        stringBuffer.append("hello");


        Ticket03 ticket = new Ticket03();
        Thread thread = new Thread(ticket,"窗口1");
        Thread thread2 = new Thread(ticket,"窗口2");
        Thread thread3 = new Thread(ticket,"窗口3");
        thread.start();//窗口一开始售票
        thread2.start();//窗口2开始售票
        thread3.start();//窗口2开始售票

        /**
         * StringBuffer 线程安全
         * StringBilder 线程不安全 效率高
         *
         * HashMap  线程不安全
         *HasTable  线程安全
         *
         * ArrayList 线程不安全
         * Victor  线程安全
         *
         *
         */


    }
}

```

# 等待唤醒机制

## 线程之间的通信

多线程在处理同一个资源，但是处理的动作（线程任务）却不同

比如，线程a是生产订单，线程b对订单付款，都是操作的同一个订单，线程a和线程b的动作是不同的，这里的线程a和线程b之间就存在线程通信

![GpWufs.png](https://s1.ax1x.com/2020/03/26/GpWufs.png)

> 多线程并发执行，在默认情况下cpu是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们需要他们有规律的执行，则多线程之间就需要一些协调通信

## 等待唤醒机制

等待唤醒机制的方法

- wait():等待，将正在执行的线程释放他的执行资格和执行权，并存储到线程池中
- notify():唤醒 ，唤醒线程池中被wait()的线程，一次唤醒一个，而且是随机的
- notifyAll():唤醒全部，可以将线程池中的所有wait()线程都唤醒

调用wait和notify方法需要注意的细节

- wait()方法和notify()方**法必须要同一个锁对象调用**，因为：对应的锁对象可以通过notify唤醒用同一个锁对象调用的wait方法后的线程
- wait()方法和notify()方法是属于object类的方法，因为：锁对象是任意对象，而任意对象所属类都是继承object类

> 我们可以使用任意对象作为锁对象

wait()和notify()方法必须要在同步代码块或者是同步函数中使用，因为：必须通过锁对象调用这两个方法

## 生产者和消费者问题（等待唤醒的实例）

创建测试类OrderApp

```java
package demo;

import java.util.LinkedList;
import java.util.concurrent.locks.Lock;

public class OrderApp {
    public static void main(String[] args) {

        //创建存储订单编号的集合
        LinkedList<Integer> list = new LinkedList<>();
        //创建订单的线程对象
        PlaceOrder r1 = new PlaceOrder(list);
        //创建付款的线程对象
        PayOrder r2 = new PayOrder(list);
        //启动下单和付款单 线程
        Thread t1 = new Thread(r1,"创建订单的线程");
        Thread t2 = new Thread(r2,"支付线程");
        t1.start();
        t2.start();

    }
}

```

创建生产订单类 placeOrder

```java
package demo;

import java.util.LinkedList;

/**
 * 用户下单类
 */
public class PlaceOrder implements Runnable {
    private LinkedList<Integer> list;
    private Integer num = 1000;//订单编号的初始值

    public PlaceOrder(LinkedList<Integer> list) {
        this.list = list;
    }
    @Override
    public void run() {

        while (true) {
            try {
                Thread.sleep(1000);
                if (list.isEmpty()) {
                    //生成订单编号
                    System.out.println("用户下单订单编号：" + ++num);
                    //将订单编号，存入集合的尾部
                    list.addLast(num);
                    synchronized (list) {
                        list.notify();       //下单成功，通知付款的线程付款
                    }
                }
                else {
                    synchronized (list) {
                        //当前线程进入等待
                        list.wait();
                    }
                }

            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
    }
}

```

创建订单支付类playorder



```java
package demo;

import java.util.LinkedList;

/**
 * 对订单付款的线程类
 */
public class PayOrder implements Runnable {
    LinkedList<Integer> list;
    public PayOrder(LinkedList<Integer> list) {
        this.list = list;
    }

    @Override
    public  void run() {

        while (true){

            try {

                if (!list.isEmpty()){
                    Thread.sleep(1000);
                    //从集合头部移除一个订单
                    Integer getorder =  list.removeFirst();
                    System.out.println("付款成功"+getorder);
                    //如果付款成功，等待下个订单再次产生订单
                    synchronized (list){
                        list.notify();//如果集合是空，通知订单产
                    }
                }else {
                    synchronized (list){
                        list.wait(); //自己进入等待状态
                    }
                }

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

```

结果如图所示：

![Gp4HAO.png](https://s1.ax1x.com/2020/03/26/Gp4HAO.png)

# 线程的生命周期

线程的生命周期是要经过**新建，就绪，运行，阻塞，死亡**五中状态。在线程启动后，他不能一直霸占到cpu独自运行，所以cpu需要在多条线程之间切花，于是线程状态会在**运行、阻塞、等待**之间频繁切换。

![GpbVv4.png](https://s1.ax1x.com/2020/03/26/GpbVv4.png)

## 新建和就绪状态

**当程序使用new关键字创建一个线程后，该线程就处于新建状态**。他这时候和其他java对象一样，仅仅由java虚拟机为其分配了内存，并初始化了其成员变量值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行该线程执行体

**当线程对象调用start()方法后，该线程就进入了就绪状态**，该线程还没有真正的运行，在就绪状态的线程表示可以运行了，至于何时运行，取决jvm里线程调度器的调度

## 运行和阻塞状态

**当就绪状态的线程如果抢占到了cpu资源，才会到达运行状态。**

当发生如下情况，线程将会进入**阻塞状态**

1. 当执行了线程对象的slee()等阻塞类型的方法，该线程就会被放在一个阻塞集合里，知道阻塞时间结束，才会又进入到就绪状态
2. 当多个线程试图进入某个同步区域时，没能进入该同步区域的线程就会被放入锁定集，知道获得该同步区域的锁，进入就绪状态
3. 当线程执行了wait()方法，线程会置入该对象的等待集中，知道执行了该对象的notify()方法，进入就绪状态
4. wait()和notify()方法的执行要求线程首先获得该对象的锁
5. 程序调用了suspend()方法将该线程挂起，处于挂起状态，该状态被调用了resume()恢复方法，进入就绪状态（此方法容易导致死锁，应该避免使用该方法）

## 死亡状态

run()方法执行完毕，程序正常结束

线程抛出一个为捕获的异常，中断线程

使用stop()方法强制中断线程（不推荐使用，应为stop()和suppend()、resume()一样，可能会发生不可预料的结果）