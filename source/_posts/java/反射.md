---
title: Java中的反射、Class类
tags:
  - Java基础
  - 反射
  - Class类
categories: Java学习笔记
declare: true
cover: >-
  https://image.baidu.com/search/down?tn=download&word=download&ie=utf8&fr=detail&url=https%3A%2F%2Ftimgsa.baidu.com%2Ftimg%3Fimage%26quality%3D80%26size%3Db9999_10000%26sec%3D1585235179980%26di%3Df71aff38a58819aea030ad5d01b2e0d1%26imgtype%3D0%26src%3Dhttp%253A%252F%252Fwww.bm0315.com%252Fuploads%252Fallimg%252F191224%252F040J32D9_0.jpg&thumburl=https%3A%2F%2Fss0.bdstatic.com%2F70cFvHSh_Q1YnxGkpoWK1HF6hhy%2Fit%2Fu%3D1444070507%2C3220770755%26fm%3D26%26gp%3D0.jpg
abbrlink: 2447437047
data: 2020-03-29 00:00:00
---



# java中的反射

## 用反射的时候

需要在运行时在得知并编译完全未知的类，创建它的对象，改变其属性，调用其方法的时候

## 反射的简介

允许程序在运行时，借助Reflection Api取得任何类的内部信息，并直接操作其属性和方法。

# 类的加载过程

- 类的加载：将class文件读入到内存，并为class文件创建一个class类的对象。由类的加载器完成
- 类的创建：将类的二进制文件合并在JRE中
- 类的初始化：由JVM进行类的初始化

# Class类

## Class类简介

在java里，一切皆对象。严格划分，java有两种对象：

1. 普通类创建的	**实例对象**
2. Class类创建的	**对象Class**

实例对象就是平常定义的一个类的实例：

```java
public class Order{

}
```

然后使用new关键字创建对象

```java
Order o = new Order()
```

Class对象是不能用new关键字来得到的，因为是**JVM生成用来保存对应类的信息的**。当我们定义好一个类文件（普通类）并编译成class字节码后，**编译器同时为我们创建了一个Class类对象将他保存在.class文件中**，同时在**jvm内部有个类加载机制**。在需要的时候将.class文件和对应的Class类的对象加载到内存中。**所以我们在加载普通类的.class文件的时候同时也会产生一个Class类对象，这个Class类是JVM自动生成的**。该Class类的对象中描述了我们编译的普通类的相关信息（成员变量属性、成员变量方法、方法类型等等所有的信息）

## 获取Class对象

不能有New关键字来获取Class对象，因为Class对象是在加载.class文件的时候JVM 创建的

### 有四种方式

1. 通过类的class属性获取

   ```java
           Class <User> cls = User.class;
   ```

2. 通过对象的getClass()方法【所有的对象都有getClass()方法】

   ```java
    Class<User> cls2 = (Class<User>) user.getClass();
   ```

3. 通过Class类的forName('类的全限定名')

   ```java
   //抛出ClassNotFoundException
   Class<?> cls3  = Class.forName("com.yq.User");//在遇到需要Class对象的时候加载User这个类的.class文件到JVM虚拟机
   ```

4. 通过类加载器获取

   ```java 
   ClassLoader classLoader =  User.class.getClassLoader();//获取到了类的加载器
           classLoader.loadClass("com.yq.User");
   
   ```

### 基本方法

- public String getName()：以String的形式返回此Class对象的实体（类、接口、数组类、基本类型或void）名称，**全限定名**

- public String getSimpleName()：返回源代码中给出的底层类的建成、如果底层类是匿名的规则返回一个空字符串，**直接名称**

运行结果：

![](https://pic.downk.cc/item/5e830548504f4bcb0410fa6c.png)

# 使用反射创建对象

## 新建User类

```java
package com.yq;

public class User {

    private  String name;
    public  int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public User() {
        System.out.println("这里是无参构造");
    }
    public  User(String name)
    {
        System.out.println("这里是有参构造方法name:"+name);
    }
    public  User(String name,int age)
    {
        System.out.println("这里是有参构造方法name:"+name+"\tage"+age);
    }
}
```

## newInstance()

- public T newInstance：创建此Class对象所表示的类的一个新实例，调用类的无参构造方法

  ```java
  //使用反射创建对象
  //1.获取User类对应的Class类的对象
  Class<User> cls = User.class;
  //2.创建User类的对象
  User user = cls.newInstance();//使用类的无参构造方法创建对象
  ```

## getConstructor()

- public Constructor<T> getConstructor(Class<?>... parameterTypes)：通过有参构造方法来创建对象

  ```java
  //1.获取User类对应的Class类的对象
  Class<User> cls = User.class;
  Constructor<User> clsConstructor  =  cls.getConstructor(String.class);
  //        3.2 调用Constructor对象的NewInstance()方法，实例化User对象
    User user = clsConstructor.newInstance("飞龙");
  /*调用多个参数的构造方法
          Constructor<User> constructor = cls.getConstructor(String.class,int.class);
          User user1 = constructor.newInstance("张三",11);
  */
  ```

  

# 使用反射访问成员变量

## getField()

getField只能访问public修饰的成员变量

```JAVA
//通过类获取Class对象
Class <User> cls = User.class;
//Field field = cls.getField("name");
Field field = cls.getField("age");
System.out.println(field.getName());//获取成员的名称
```

## getDeclaredField

可以访问private修饰的成员变量

```java
//通过类获取Class对象
Class <User> cls = User.class;
User user = new User();
user.age=15;
user.setName("小飞龙");
Field field = cls.getDeclaredField("name");
System.out.println(field.getName());//获取成员的名称
field.setAccessible(true);//设置私有成员变量可以被访问
System.out.println(field.get(user));//获取成员变量的内容
```

## 获取类的所有字段

```Java
  //通过类获取Class对象
        Class <User> cls = User.class;
        
//        获取类的所有字段
//        Field[] field = cls.getFields();
        User user = new User();
        user.setName("李四");
        user.age=22;
        Field[] field = cls.getDeclaredFields();
        for (Field field1 :field){
            field1.setAccessible(true);
            //判断字段是那种数据类型
            String filetype = field1.getType().getName();
            if (filetype.equals(String.class.getName()))
            {
                System.out.println(field1.getName()+":"+field1.get(user));
            }
        }
```

# 使用反射访问成员方法

## 访问成员方法

这里**通过Class对象调用getMehods方法来访问获取目标类中的所有public修饰的成员方法返回一个Method类型的数组**

使用getMethod方法则可以访问固定的目标方法

## 调用成员方法

在调用访问到的成员方法的时候用Method对象调用invoke(目标类的对象);

## 代码示例

```java
  //通过类获取Class对象
  Class <User> cls = User.class;

  //获取子类和它父类所有的方法只能访问public修饰的方法
  //Method [] methods = cls.getMethods();
  //拿到子类中的所有public方法 非构造方法
  Method [] methods = cls.getDeclaredMethods();
  for (Method method : methods){
      System.out.println("子类中所有的方法："+method.getName());
  }

//  Method method = cls.getMethod("introduce");
  Method method = cls.getDeclaredMethod("introduce");
  System.out.println(method.getName());
  method.setAccessible(true);//让私有方法可以被调用
  //调用方法 User类的对象
  method.invoke(new User());
```

# 使用反射访问构造方法

## 访问构造方法

Constructor<T> getConstructor(Class<?>... parameterTypes)：获取需要访问的构造方法

## 通过反射调用构造方法

constructor.newInstance("飞龙", 22);：使用Constructor对象调用newInstance方法来调用该构造方法

## 代码示例

```java
 //通过反射的机制给变量赋值
 Class<User> cls = User.class;
 //通过反射获取构造方法
 Constructor<User> constructor = cls.getConstructor(String.class, int.class);

 //通过反射调用构造方法
User user =  constructor.newInstance("飞龙", 22);

 //通过反射访问成员变量
 Field[] fields = cls.getDeclaredFields();
 for (Field field : fields) {
     field.setAccessible(true);
     System.out.println("所有的变量名："+field.getName());
     if ("age".equals(field.getName())) {
         field.set(user, 29);
     }
     if ("name".equals(field.getName())) {
         field.set(user, "张三");
     }
 }
 System.out.println(user.getName());
 System.out.println(user.age);
```

# 通过反射调用方法代码总汇

```java
package com.yq;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class RdflectionDemo05 {

    public static void main(String[] args) throws Exception {

        //通过反射的机制给变量赋值
        Class<User> cls = User.class;
        //通过反射获取构造方法
        Constructor<User> constructor = cls.getConstructor(String.class, int.class);

        //通过反射调用构造方法
       User user =  constructor.newInstance("飞龙", 22);


      Method method =  cls.getDeclaredMethod("setName",String.class);
      method.setAccessible(true);
      method.invoke(user,"王五");

      Method method1 =cls.getDeclaredMethod("getName");
      method1.setAccessible(true);
     Object object = method1.invoke(user);
        System.out.println(object);
        //通过反射访问成员变量
//        Field[] fields = cls.getDeclaredFields();
//        for (Field field : fields) {
//            field.setAccessible(true);
//            System.out.println("所有的变量名："+field.getName());
//            if ("age".equals(field.getName())) {
//                field.set(user, 29);
//            }
//            if ("name".equals(field.getName())) {
//                field.set(user, "张三");
//            }
//        }
        System.out.println(user.getName());
        System.out.println(user.age);

    }


}
```